{"pages":[{"title":"","text":"","link":"/tags/index.html"},{"title":"","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index-1.html"},{"title":"categories","text":"","link":"/categories/index-1.html"},{"title":"tags","text":"","link":"/tags/index-2.html"}],"posts":[{"title":"Flex 上課筆記","text":"Note:display:必備屬性flex-direction:決定flex軸線justify-content:主要軸線的對齊align-items:交錯軸線的對齊 Flex 外層屬性 (container) 介紹父元素有 display:flex，內層子元素之間的比例就會自動調整位置 1234.container .item.item1 1 .item.item2 2 .item.item3 3 即使item寬度調成 200 5000 10000 px，也不會超出 container，因為父層有display:flex，但內層如果單一設定高度，其他項目也會跟著一起變更高度若在 item1、2、3 個別加上屬性值會呈現下圖 1234567891011121314151617181920212223242526.container { width: 500px; background: #0099ff; margin: 0 auto;}.container .item { background: #00ffa2; color: #d32a2a; text-align: center; font-size: 36px; margin-bottom: 10px;}.container .item1 { height: 150px; width: 150px;}.container .item2 { height: 200px; width: auto; //因為沒設定寬度，所以會自適應延伸父元素， //父元素寬多少ex:500px，子元素寬就會多少ex:500px}.container .item3 { height: auto; width: 400px;} 即使item寬度調成 200 5000 10000 px，也不會超出 container，因為父層有display:flex，但內層如果單一設定高度，其他項目也會跟著一起變更高度 若在 item1、2、3 個別加上屬性值 1234567891011121314151617181920212223242526.container { width: 500px; background: #0099ff; margin: 0 auto;}.container .item { background: #00ffa2; color: #d32a2a; text-align: center; font-size: 36px; margin-bottom: 10px;}.container .item1 { height: 150px; width: 150px;}.container .item2 { height: 200px; width: auto; //因為沒設定寬度，所以會自適應延伸父元素， //父元素寬多少ex:500px，子元素寬就會多少ex:500px}.container .item3 { height: auto; width: 400px;} 會呈現下圖若在.container css 加上display: flex 跟 .item + margin: 0 0 10px 10px會呈現下圖item3 因為沒設定高度，所以會依照.item2的高度自適應延伸item1 因為”有”設定高度，所以不會自適應延伸如果item都沒設定高度，就會依照元素內的內容設定高度note: item預設是等高(or寬)的，會依照container內部距離自動調整 codepen範例 Flex-direction 排版方向flex-direction: row flex-direction: row-reverse flex-direction: colume flex-direction: colume-reverse justify-content — 決定主軸對齊方式 123display: flexflex-direction: columnjustify-content: space-between 要改變方向要下display: flex &amp; flex-direction: column(垂直)row橫向本身是預設可不寫 六角 Flex 模擬器TEST CSS FLEXBOX RULES 資料來源:六角學院-Flex 網頁排版技巧資料來源:職人必修的 RWD 網頁入門班","link":"/2020/08/13/202008013-d-dlex/"},{"title":"v-if","text":"v-ifCodePen我想透過勾選來決定要不要顯示 h1 標籤的內容，顯用 v-model 綁定屬性，再用 v-if 判斷決定與否 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot; &gt; &lt;h1 v-if=&quot;checked&quot;&gt;Hello World!&lt;/h1&gt;&lt;/div&gt;&lt;!-- Scss --&gt;&lt;!-- #app{ text-align: center; h1{ font-size: 30px; color: red; }} --&gt; 123456let vm = new Vue({ el:&quot;#app&quot;, data:{ checked: false, }}) v-if 除了可以用在元素上，也可以用 template 模板包住某些元素 這樣一個一個寫在元素太麻煩，所以改成直接寫在 template 模板上，會有一樣的效果 12345678910&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot; &gt;&lt;!-- &lt;h1 v-if=&quot;checked&quot;&gt;Hello World!&lt;/h1&gt; --&gt; &lt;template v-if=&quot;checked&quot;&gt; &lt;h1&gt;html&lt;/h1&gt; &lt;h2&gt;javascript&lt;/h2&gt; &lt;h3&gt;css&lt;/h3&gt; &lt;/template&gt;&lt;/div&gt; 123456let vm = new Vue({ el:&quot;#app&quot;, data:{ checked: false, }}) 在勾選顯示時，用開發者工具看會顯示 DOM 元素 但是不勾選時，DOM 元素會直接被拿掉而不是用 display:none 隱藏 v-elseCodePen 12345&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot; &gt; &lt;h1 v-if=&quot;checked&quot;&gt;Hello World!&lt;/h1&gt; &lt;h1 v-else&gt; OverWatch&lt;/h1&gt;&lt;/div&gt; 123456let vm = new Vue({ el:&quot;#app&quot;, data:{ checked: true, }}) 不是 A 就是 B，當 v-if 屬性是 false 時，則會顯示 v-else，而 v-if 跟 v-else 之間不能有任何元素，若出現其他元素 v-else 就不會觸發用開發者工具看，會發現一樣不是透過 display:none 隱藏 v-else-ifCodePen v-if 跟 v-else 是簡單的二元判斷，那v-else-if 是提供兩者之間的選擇，介於 v-if 跟 v-else 之間，同時很多個 v-else-if 也沒關係! 1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checkedOne&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checkedTwo&quot;&gt; &lt;h1 v-if=&quot;checkedOne&quot;&gt;勾選 checkedOne!&lt;/h1&gt; &lt;h1 v-else-if=&quot;checkedTwo&quot;&gt;勾選 checkedTwo&lt;/h1&gt; &lt;h1 v-else&gt; checkedOne、checkedTwo，都不是&lt;/h1&gt;&lt;/div&gt; 1234567let vm = new Vue({ el:&quot;#app&quot;, data:{ checkedOne: false, checkedTwo: false, }}) 再都不勾選情況下: 勾選 checkedOne: 勾選 checkTwo: 兩個都勾，會顯示 checkedOne 是因為判斷第一個 v-if 已經成立 v-showv-if 是透過刪除 DOM 元素來決定顯示與否，但如果要透過 CSS 的 display:none來控制 並且在不刪除 DOM 情況下，這時就要用 v-show 。 v-show 有兩個地方要特別注意:1. 沒有 v-else2. 不能用 template 1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checkedOne&quot;&gt; &lt;h1 v-show=&quot;checkedOne&quot;&gt;勾選 checkedOne!&lt;/h1&gt;&lt;/div&gt; 1234567let vm = new Vue({ el:&quot;#app&quot;, data:{ checkedOne: false, checkedTwo: false, }}) 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/13/20200813-vue-if/"},{"title":"列表渲染","text":"8-1用 v-for 把陣列轉換為一組元素將 data 裡面的 todo 陣列顯示在 li 上，v-for=&quot;todos in todo&quot; 後面的todos 代表陣列，前面的todo 代表陣列裡面的每個元素 12345&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;todos in todo&quot;&gt;{{todos}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910new Vue({ el:&quot;#app&quot;, data:{ todo:[ &quot;html&quot;, &quot;javascript&quot;, &quot;css&quot;, ], }}) 下拉選單12345&lt;div id=&quot;app&quot;&gt; &lt;select&gt; &lt;option v-for=&quot;month in months&quot;&gt;{{month}} &lt;/select&gt;&lt;/div&gt; 123456new Vue({ el:&quot;#app&quot;, data:{ months:[1,2,3,4,5,6,7,8,9,10,11,12], }}) codepen 這種數字的有另一個寫法，可以將 months 改寫成數字，而改寫的數字就會是最大值，而 months 的陣列可以刪除。範例如下: 12345&lt;div id=&quot;app&quot;&gt; &lt;select&gt; &lt;option v-for=&quot;month in 30&quot;&gt;{{month}}&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 12345new Vue({ el:&quot;#app&quot;, data:{ }}) 這樣就會有30個數字選項 月份綁 value這是在陣列是字串下，但又希望 value 值是數字 123，這時可以在 month 後面加上 index 或是 idx 、 i 等等任意變數，再用 v-bind 綁 value 12345&lt;div id=&quot;app&quot;&gt; &lt;select&gt; &lt;option v-for=&quot;(month, index) in months&quot; :vlaue=&quot;index+1&quot;&gt;{{month}}&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 12345678new Vue({ el:&quot;#app&quot;, data:{ months:[ 'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec' ] }}) codepen 8-2用 v-for 把一個物件轉換為一組元素如果要取物件內的 key 值，就在 value 後面加上 key 就好跟陣列很像，陣列是 (元素, idx) ，物件是 (value, key) 12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key) in obj&quot;&gt;{{key}} : {{value}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ obj:{ // 前面為 key: 後面為 value name : &quot;PKT&quot;, number : &quot;123456&quot;, age : &quot;22&quot;, } },})&lt;/script&gt; v-for 轉物件，渲染出來的順序不一定會跟我寫的一樣，例如我用不規律的數字做開頭 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key) in obj&quot;&gt;{{key}} : {{value}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ obj:{ name : &quot;PKT&quot;, number : &quot;123456&quot;, age : &quot;22&quot;, 12 : '中餐', 8 : '早餐', 6 : '晚餐', 2 : '宵夜', } },})&lt;/script&gt; 渲染出來的結果會長這樣明明我的順序是 12 =&gt; 8 =&gt; 6 =&gt; 2，但是選染出來卻是按照順序排列，這是因為我們用 v-for 來轉物件，若真要按照順序排列的話 code 也不會這樣打，但這是特定情況，必須依照我寫 code 的順序排列，所以就要用 v-for 轉陣列的方式，來修正。 先把物件轉陣列型式，並且在陣列內新增 prop &amp; value 屬性再把 v-for 轉成陣列，下面的 obj 是陣列 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in obj&quot;&gt;{{item.prop}} : {{item.value}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ obj:[ { prop: 'name', value: &quot;PKT&quot;}, { prop: 'number', value: &quot;123456&quot;}, { prop: 'age', value: &quot;22&quot;}, { prop: 12, value: '中餐'}, { prop: 8, value: '早餐'}, { prop: 6, value: '晚餐'}, { prop: 2, value: '宵夜'}, ] },})&lt;/script&gt; code這樣就可以依照我指定的順序來顯示了 修改陣列或物件的注意事項常用語法： push: 新增數字 pop: 減少數字 shift: 移除並回傳陣列的第一個元素 unshift: 從陣列開頭塞數字 splice: 從頭數到第 X 個，移除 Y 個，加入 Z sort: 把亂掉的順序，按順序排列 reverse: 順序顛倒1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for='item in nums'&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click='add'&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data:{ nums:[1,2,3,4,5], // sort 用 // nums:[1,3,5,7,2,4,6,8], }, methods:{ add(){ // this.nums.push(this.nums.length+1); // this.nums.pop(); // this.nums.shift(); // this.nums.unshift(0); // this.nums.splice(idx, length); // this.nums.splice(2, 1, 9,8,7,); // // this.nums.sort(); // this.nums.reverse(); } }})&lt;/script&gt; code filter文件filter 會把陣列內的所有元素拿去跑函式，同時又不會更動原本的陣列，而是產生新的陣列。那函式跑完回傳的值是 true ，就會產生新的陣列，是 false 就不會有新元素出現在新陣列內。 簡言之，就是把原本的陣列過濾並產生新的陣列。 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for='item in nums'&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click='add'&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data:{ nums:[1,2,3,4,5,6,7,8,9] }, methods:{ add(){ this.nums = this.nums.filter( elm =&gt; (elm%2 ===0)); } }})&lt;/script&gt; code過濾後會變成下圖 修改陣列並反應在元素上想感變陣列內的值可以用 splice 12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for='item in nums'&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click='add'&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data:{ nums:[1,2,3,4,5,6,7,8,9] }, methods:{ add(){ // 這樣是不會有任何反應的 // this.nums[0] = 10; // 從第2個，移除1個，加入789 或是 單值 // 從第0開始算，移除1開始算 // this.nums.splice(2, 1, 7,8,9); // 從第 X 個之後都移除掉 // 移除1開始算 // this.nums.splice(2); // 只保留從 X 到 Y，其他移除掉 // 從第0開始算，移除1開始算 // slice(從, 第) // this.nums = this.nums.slice(1, 4); } }})&lt;/script&gt; code 物件內新增值以上都是 v-for 轉陣列，現在是轉物件，並在物件內新增值 新方法 $set(設定屬性的物件, 設定物件的 key, key 的值) 1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for='(item, key) in nums'&gt;{{key}}: {{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click='add'&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data:{ nums:{ x: 10, y: 20, }, }, methods:{ add(){ // 這樣是無法新增的 // this.nums.z = 30; this.$set(this.nums, 'z', 30); // 除了 $set 還可以用 Vue，但是用 Vue 就沒有$ Vue.set(this.nums, 'z', 30); } }})&lt;/script&gt; code這樣就可以新增了 以上是示範物件內原本沒有的，但是要新增新的物件，才會用到 set那如果原本就有的，但是要修改原本的物件要怎麼寫? 以下示範 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for='(item, key) in nums'&gt;{{key}}: {{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click='add'&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el: '#app', data:{ nums:{ x: 10, y: 20, }, }, methods:{ add(){ this.nums.x = 30 } }})&lt;/script&gt; code 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/13/20200813-v-for/"},{"title":"MVVM 說明","text":"MVVM 就由這三個東西之間的作用，可以比較好管理開法者的內容 透過使用者的 view 操作來影響 view model ，只要在 view 裡面操做， view model 同時也會跟著變動，也同時修改 model 的內容，那 view model 資料發生變動，又會同時改變 View 顯示的內容，所以他們三個是互相交互作用的 Vue 強大的地方在於 Vue 組件，他可以把龐大的 App 分裝，把相關的功能集中，讓這些組件獨立封裝而且好維護也好測試 vue 組件可以把模板跟實例還有CSS統一放在裡面，讓我們很好的去做開發跟管理. 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/13/20200813-vuemvvm/"},{"title":"最常見的 this：物件的方法調用","text":"函式裡面一定會帶上一個 this ， this 在執行函式的時候自然就會產生，不需要特別宣告 作用域不一樣，var的作用域在函數 (function) 裡，let的作用域則是在區塊 (block) 裡。 範例 11234567891011var myName = '驚不驚喜';function callName() { console.log(this,this.myName);}var family = { myName: '老王', callName: callName}family.callName(); this 會指向函式前面的物件，所以 this 顯示 family 物件， this.myName 會顯示老王 範例 212345678910111213141516var myName = '驚不驚喜';function callName() { console.log(this,this.myName);}var family = { myName: '來因', callName: callName, ana: { myName: '安納', callName: callName }}family.callName();family.ana.callName(); 這邊 family 裡面多了 ana 物件，執行 family.callName() 會找到物件第一層，跟範例 1 一樣在執行 family.ana.callName() 時，callName()的 this 會指向 ana 物件 範例 312345678910111213141516var myName = '驚不驚喜';function callName() { console.log(this,this.myName);}var family = { myName: '來因', callName: function () { console.log(this, this.myName); }}// family.callName();var callName = family.callName;callName() 如果執行 family.callName() 結果會跟範例 1 一樣，但如果重新宣告 callName 再執行結果為什麼會是 驚不驚喜 ?因為callName 是在全域執行，所以 this 就不會指向 family 這個物件，是指向全域的 window ，而全域 window 的 myName 就是 驚不驚喜 。就算少了 var callName = family.callName; 結果仍是一樣 參考資料: JavaScript 核心篇","link":"/2020/08/13/20200813-javascript/"},{"title":"Javascript 核心篇-執行環境","text":"JavaScript 是直譯式語言當 JavaScript 在函示內找不到變數就會向外查找window === this但this會隨執行環境而有所不同 語法作用域 (Lexical scope)12345678910var value = 1;function fn1() { console.log(value); // 語法作用域：1 // 動態作用域：2}function fn2() { var value = 2; fn1();}fn2(); 語法作用域的順序:(因為 JS 式語法作用域，所以會跑這個步驟)fu2 執行 value 值就會變 2 ，在執行 fn1 ，因為裡面沒有 value 值所以會向外查找全域變數 value = 1，函式執行完結果為1 動態作用域的順序: 全域賦予 value=1，這時候會執行 fn2 ，並且重新定義 value = 2 ，再執行 fn1 ，這時會開始查找 value 值在哪裡，這時因為函式調用的時候才會決定它的作用域，並向上一層函式查找宣告的變數值 範圍鍊123456789101112131415var person = '老媽'function sayHi() { console.log('hi ' + person);}function doMorningWork() { var person = '老爸'; function meetAuntie() { var person = '漂亮阿姨'; console.log('哈囉～ ' + person); } // sayHi(); //meetAuntie();} sayHi();//doMorningWork(); // 執行 因為 sayHi function 裡面沒有 person 變數，所以會向外尋找 123456789101112131415var person = '老媽'function sayHi() { console.log('hi ' + person);}function doMorningWork() { var person = '老爸'; function meetAuntie() { var person = '漂亮阿姨'; console.log('哈囉～ ' + person); } sayHi(); //meetAuntie();} //sayHi(); doMorningWork(); // 執行 doMorningWork 函式雖然有 person 變數，但不會影響到 sayHi 函式的範圍練，所以 sayHi 函式一樣會向外尋找 person 變數 123456789101112131415var person = '老媽'function sayHi() { console.log('hi ' + person);}function doMorningWork() { var person = '老爸'; function meetAuntie() { var person = '漂亮阿姨'; console.log('哈囉～ ' + person); } // sayHi(); meetAuntie();} //sayHi(); doMorningWork(); // 執行 因為 meetAuntie 函式本身就有 person 變數，所以不會像尋找，結果為 哈囉~ 漂亮阿姨如果把 var person = ‘漂亮阿姨’; 註解掉，那 person 變數會向外尋找。結果為 哈囉~老爸 論是: 只要函式內沒找到相對應的變數，就會像向外一層尋找相對應的變數，直到找到為止 提升先想像記憶體是成對的，左邊的格子表示 key，右邊是 value。再創造環境的時候，會先把 a (變數)放到記憶體裡面(左邊格子)，但這時候還不會給 a 值，所以用 console.log 的時候會 defined ，等到執行時才會把 1 套到 a 裡面。 所以執行環境的時候會先創造環境，創造環境會先把程式碼裡面的變數全部挑出來並存在記憶體上，這個動作稱為”提升 Hoisting”，在這個階段還不會給他值，所以如果在此時去取用這些變數的話，值會是 undefined。到執行環境的時候才會賦予它的值 再創造階段 a 是沒有值的，所以會顯示 undefined，直到宣告階段才會把值帶入 。但是函式會把整個函式內容都先載入，所以函式再創造階段就已經可以運行了。 1234567891011121314151617var ming; //創造階段ming = &quot;小名&quot;; //執行console.log('ming');callName();function callName(){console.log('呼叫小名');}//會等於下列//-----------------------//創造階段function callName(){console.log('呼叫小名');}//執行callName(); 函式表達式寫法:1234callName() //這時候的 callName 是還沒有被定義的var callName = function(){console.log('呼叫小名');} 輸出如下圖: 12345678//創造階段var callName(); //這時候 callName 被定義了但沒給值，所以會undefine//執行callName = function(){ //這時 function 已經被賦予到 callName 這個函式上 console.log('呼叫小名'); } callName(); //才可呼叫 範例:1234567891011121314151617181920// var callName = function () {// console.log('呼叫小明 2');// }// function callName() { // console.log('呼叫小明 1');// }// callName();//以上為原式//-----------------------------------//拆解過後function callName() { // 首先函式優先 創造階段 console.log('呼叫小明 1'); }var callName;//第2階段才把變數往前移callName = function () { //因為變數往前移的關係，這時 function 已經被賦予到 callName 這個函式上 console.log('呼叫小明 2'); }//執行callName(); 範例:123456789//創造，函式陳述式優先創造function callName() { console.log('小明'); } callName(); // 第一次執行function callName() { console.log('杰倫'); } 拆解&amp;分析:12345678910// 創造function callName() { console.log('小明');}function callName() { console.log('杰倫');}// 執行callName(); // 第一次執行callName(); // 第二次執行 兩個函式長一樣，後面得值會蓋掉前面的值 測驗分析:12345678function whosName() { if (name) { name = '杰倫'; }}var name = '小明';console.log(name);whosName() 因為創造階段，函式陳述式優先創造，變數 name 只生出記憶體，並未賦予值執行階段，呼叫 whosName 的函式時，name 向外查找 name 變數，但未賦予值，所以在 whosName 裡面的 name 被賦予為”杰倫”的值函式跟一般變數不太一樣，函式陳述式在創造環境階段會被優先載入，記憶體在這個階段就會有函式的完整內容。所以函式在創造環境階段就已經可以被運行。 Not Defined VS undefined12var a ;console.log(a) //輸出 undefined 因為記憶體已經有 a 了，但沒有賦值，所以會跳 undefined同理，記憶體沒有 a 就會跳 Not Defined 12//如果要賦予空值要寫var a = null; 執行緒與同步、非同步JavaScript 是單執行序的語言 12345678910111213141516171819function eatBreakfast() { console.log('吃早餐');}function washingPlate() { console.log('洗餐盤');}function callSomeone(someone) { console.log('打給' + someone) setTimeout(function () { //這段為非同步，而非同步的任務會移到事件佇列 console.log(someone + '回電'); }, 1000); //就算這邊秒數調成0秒，也不會優先執行}function doWork() { var auntie = '漂亮阿姨'; eatBreakfast(); callSomeone(auntie); washingPlate();}doWork(); 同步概念來看的話，這三個概念是依序執行的，不會有早餐沒吃完就跳到洗碗盤去 執行順序為: do work 吃早餐 打給漂亮阿姨，但因為裡面有 SetTimeout 事件，所以會移到”事件佇列”裡面 洗碗 直到 do work 執行完後才會再去執行 SetTimeout 函式 參考資料: JavaScript 核心篇","link":"/2020/08/13/20200813-javascript%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"v-bind 及 v-on 的使用","text":"v-bindv-bind 指令是用來把一個數值綁定到 HTML 屬性上，因為到後期會大量用到，所以會使用縮寫 “ : “ 用 v-bind 製作一個簡單的按鈕123456789101112&lt;div id=&quot;app&quot;&gt; &lt;button :type=&quot;selected&quot;&gt;selected&lt;/button&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el:&quot;#app&quot;, data:{ selected: 'submit', } })&lt;/script&gt; codepen 透過 v-bind 可以將 submit 這個值綁到 type 屬性上 v-onv-on 縮寫為 “@”，用來偵聽 DOM 輸入的事件並改變資料 製作一個簡單的按鈕123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; :checked=&quot;selected&quot;&gt; &lt;button @click=&quot;toggle&quot;&gt;toggle&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ selected: false, }, methods:{ toggle(){ this.selected = !this.selected; } }})&lt;/script&gt; codepen checked 屬性是控制 input 著 checkbox 有沒有被勾選到，而 selected 這個值是代表 data 裡面的 selected，要讓 selected 賦予值，就必須要用 v-bind 動態綁定到 checked 屬性上，再透過 v-on 偵聽事件綁定 selected。 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/13/20200813-vueon/"},{"title":"下拉選單","text":"年份選擇將 select 用 v-model 做作雙向綁定，因為 number 是空字串，所以在一開始 option 會指定到 value 為空值的選項。假設 option 裡面沒有 value ，那 option 就會顯示 2020 等年分，但給了 value 就會顯示 value 值。 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;number&quot;&gt;&lt;!-- 第一個預設 disabled， value 可能給空值或是-1 --&gt; &lt;option disabled value=&quot;&quot;&gt;select number&lt;/option&gt; &lt;option value=&quot;001&quot;&gt;2020&lt;/option&gt; &lt;option value=&quot;002&quot;&gt;2021&lt;/option&gt; &lt;option value=&quot;003&quot;&gt;2022&lt;/option&gt; &lt;!--&lt;option&gt;2020&lt;/option&gt; &lt;option&gt;2021&lt;/option&gt; &lt;option&gt;2022&lt;/option&gt; --&gt; &lt;/select&gt; &lt;h1&gt;{{number}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ number: '', }})&lt;/script&gt; codepen 除了以上方法將每個選項都寫出來，還可以用 v-for 來做下拉選單並綁定到陣列上，如下 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;select&gt; &lt;option v-for=&quot;number in numbers&quot; :value=&quot;number&quot;&gt;{{number}}&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ numbers: [2020, 2021, 2022], }})&lt;/script&gt; 利用 v-for 的方式將 option 內的 value 指定為 number，再用 v-model 將初始值設定為 2020，範例如下 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;selectNumber&quot;&gt; &lt;option v-for=&quot;number in numbers&quot; &gt;{{number}}&lt;/option&gt; &lt;/select&gt; &lt;h1&gt;{{selectNumber}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ numbers: [2020, 2021, 2022], selectNumber: 2020, }})&lt;/script&gt; codepen 月份選擇更為簡潔的寫法，範例如下 直接在 option 裡面寫最大數字，並將初始值 selectMonth 設定為 1，這樣就有下拉選單裡面有包含 12 個數字 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;selectMonth&quot;&gt; &lt;option v-for=&quot;month in 12&quot; &gt;{{month}}&lt;/option&gt; &lt;/select&gt; &lt;h1&gt;{{selectMonth}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ selectMonth: 1, }})&lt;/script&gt; codepen 陣列包物件寫法透過陣列將陣列內的物件顯示出來 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;selectGender&quot;&gt; &lt;option v-for=&quot;option in options&quot; :value='option.value'&gt;{{option.text}}&lt;/option&gt; &lt;/select&gt; &lt;h1&gt;{{selectGender}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ options: [ { value:1, text:'boy'}, { value:2, text:'girl'}, { value:3, text:'others'} ], selectGender: 1, }})&lt;/script&gt; codepen 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/13/20200813-select/"},{"title":"圖片上傳","text":"在檔案上傳的 input 是沒辦法用 v-model ，所以必須改用 v-on 的 change 事件 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;file&quot; @change=&quot;selectFile&quot;&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, methods:{ selectFile(e){ const file = e.target.files.item(0); console.log(file); }, },})&lt;/script&gt; codepen e 就是 @change 的事件， e.target 就是發出事件的 input，後面的 files 是 filelist 的資料型態，用 console.log 可以看到以下屬性 但目前圖片還是沒辦法顯示，只能透過建立一個 FileReader ，並偵聽 FileReader 的 load 事件，如下 1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;file&quot; @change=&quot;selectFile&quot;&gt; &lt;img :src=&quot;image&quot; width=&quot;200&quot;&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ image: '', }, methods:{ selectFile(e){ const file = e.target.files.item(0); // console.log(file); const reader = new FileReader(); reader.addEventListener('load', this.imageLoaded); reader.readAsDataURL(file); }, imageLoaded(e){ this.image = e.target.result; // e.target.result就是讀取 DataURL 檔案內容的字串 }, },})&lt;/script&gt; [codepen](https://gist.github.com/PKTseng/6021dcb601d9caf875d87589567c8979 在 input 裡的 type 是 file 的時候，e.target 就會有 files 屬性，如果在 input 標籤加上 multiple ，檔案會變成可以複選，但目前只要一個檔案，所以加上 item(0) ，然後建立一個新的 FileReader 並偵聽 load 事件，一旦 load 完，就會呼叫 imageLoaded 函式，在reader 偵聽之後會 readAsDataURL ，DataURL 是指下圖很長的字串，也稱為 base64 編碼 ( base64 編碼就是可以把很長的英文跟數字轉成字串)，那這編碼可以指定成 data 裡面的 image 同時第 3 行 img 也會被當成 source。當 reader 發出 load 事件的時候就可以偵聽 imageLoaded 事件，並呼叫第 15行 imageLoaded 函式，函式會將 load 事件當成參數(e)，e.target 就是指第 11 行發出 load 事件的 reader 物件，reader 完之後會 result DataURL 屬性，在江 DataURL 指定到第 4 行的 image 。 那有時候圖會是壞掉的，如下圖 這時候可以在 img 標籤加上 v-if =&quot;image&quot; 來判斷要不要顯示圖片 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/13/20200813-vue/"},{"title":"Vue-cli","text":"Vue-cli 是一個用單一檔案組件來開發，就是 html 、css 、 javascript 都是放在同一個檔案裡面，所以一個檔案就是一個組件。那想要用這個檔案必須要經過轉換跟打包才能讓瀏覽器執行，那在執行 Vue-cli 之前必須先知道並運用以下工具。 Node.jsNode.js 是一個可以讓電腦執行 javascript 的環境，拿原本可以跑 js 的是瀏覽器，要在瀏覽器之外可以跑 js 就會需要 node.js安裝的時候選 LTS ( Long-term support 長期支援) ，因為 Node.js 團隊會長期維護此版本，所以可以安心使用。 npmnode.js 安裝好之後，裡面有個工具叫做 npm ， 它是 node.js 裡面的一個指令，也是別人把程式寫好然後發佈到 npm 雲端，那我們就可以利用 npm 指令下載別人寫好的套件。 webpacknpm 套件裡面有個東西叫 webpack ，它會將原始檔裡面的所有資源，經過轉換+打包變成瀏覽器看得懂的語言，例如: sass =&gt; css 。 Vue-cli雖然 webpack 可以將眾多原始檔轉換打包，但在設定上會比較繁雜，所以這時候 vue 開發者就很佛心地幫我們建立一套開發工具: vue-cli ，利用 vue-cli 就可以讓我們很迅速的建立開發模板，同時也可以幫我們用 webpack 打包原始檔。 安裝此為舊版安裝方法(v2 版本)如官方說明 npm install -g @vue/cli這樣 npm 就會從雲端下載 vue-cli 到我的電腦裡面，同時也讓我的 node.js 可以執行 vue-cli，安裝時間大概2~3分鐘安裝完後會顯示版本: @vue/cli@4.5.3 如果沒安裝全域 cli 出現的錯誤，如下圖 繼續安裝步驟1.在桌面創建專案資料夾(我的範例是 v2)2.在切換到資料夾: cd 把資料夾托過來，出現第二行3.(舊版安裝方法) vue init 樣板(下圖) 專案名(v2)，接下來依照個人需求跟喜好來設定 4.安裝結束後會跳出下圖 5.再輸入黃色指定 . 6.輸入網址就會出現下圖畫面 此為 GUI 安裝方法1.創建資料夾(我的是 v3)，不要創資料夾也可以，但創建的路徑要自己決定，我在桌面創 v3 是希望創建完就出現在我指定的地點2.切換到資料夾，並輸入 vue ui 輸入後會開啟新視窗 接下來要新建專案 管理器，我習慣用 npm手動一照個人喜好設定 按下新增專案後會問你要不是把現在的設定保存起來，日後可以直接呼叫 資料來源:精通 VueJS 前端開發完全指南node.js 官方文件webpack 官方文件vue-cli 官方文件","link":"/2020/08/14/20200814-vue-cli/"},{"title":"JavaScript 網頁事件處理","text":"學習方向 介面:如何改變事件 事件:如何監聽事件並做出反應 資料:如何跟 sever 交換資料 eventListener 與 callback functioneventListener給一個屬性跟屬性值，再用 document.querySelector 選一個元素並命名為 app ，透過點擊 hello world 做出彈跳視窗，那想做出彈跳視窗必須偵聽事件 addEventListener ，在 addEventListener 前面是事件的動作例如點擊或是按鍵盤…等等，那後面要傳入一個函式。 callback function因為不知道使用者甚麼時候才會觸發函式(做甚麼動作)，所以我們必須跟瀏覽器說一但點擊了甚麼按鈕或是做了什麼動作(事件)，就幫我呼叫那個函式(觸發)，那呼叫函式就是 callback function EX: 123456789101112131415161718192021&lt;div class=&quot;app&quot;&gt; &lt;a href=&quot;#&quot;&gt;hello world&lt;/a&gt;&lt;/div&gt;&lt;!-- -------------------------------------------&gt;&lt;!-- 匿名函式 比較常見寫法--&gt;&lt;script&gt;let app = document.querySelector('.app');app.addEventListener('click',function(){ alert('hello world');})&lt;/script&gt;&lt;!---------------------------------------------&gt;&lt;script&gt;let app = document.querySelector('.app');app.addEventListener('click', onClick)function onClick(){ alert('hello world');}&lt;/script&gt; event(e)當我們觸發事件時，瀏覽器就會把參數(event 縮寫為 e)帶入函示裡面。使用 console.log(e) ，可以看到很多關於 e 的參數。 12345678910&lt;div class=&quot;app&quot;&gt; &lt;a href=&quot;#&quot;&gt;hello world&lt;/a&gt;&lt;/div&gt;&lt;script&gt;let app = document.querySelector('.app');app.addEventListener('click',function(e){ console.log(e);&lt;/script&gt; 改用 console.log(e.target) 當然如果想知道按鍵參數的話可以這樣寫先改為全域 window 1234567&lt;input type=&quot;text&quot; class=&quot;app&quot;&gt;&lt;script&gt;window.addEventListener('keypress',function(e){ console.log(e.keyCode);})&lt;/script&gt; 分別按下 a、b、c，可以知道 a = 97 、b = 98、c = 99 表單事件處理 onSubmit這可以應用在表單二次確認密碼的時候寫出一個簡單的表單，並在判斷式內擷取密碼的值( value ) 1234567891011121314151617181920212223&lt;form class='login'&gt; username:&lt;input type=&quot;text&quot;&gt; &lt;br&gt; password:&lt;input type='password' class=&quot;password&quot;&gt; &lt;br&gt; password:&lt;input type='password' class=&quot;password1&quot;&gt; &lt;br&gt; &lt;input type='submit'&gt;&lt;/form&gt;&lt;scrip&gt;let login = document.querySelector('.login');login.addEventListener('submit',function(e){ let psw = document.querySelector('.password'); let psw1 = document.querySelector('.password1'); if(psw.value !== psw1.value){ alert('密碼錯誤'); e.preventDefault(); }else{ alert('密碼正確'); }})&lt;/scrip&gt; codepen 事件傳遞機制-捕獲跟冒泡事件1234567891011121314151617&lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;two&quot;&gt; &lt;button&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;addEvent('.one');addEvent('.two');addEvent('button');function addEvent(className){ document.querySelector(className) .addEventListener('click', function(){ console.log(className) })}&lt;/script&gt; codepen 當我點擊綠色區塊的時候只會跳出 one ，但點擊 click 時就會跳出上圖，但我明明只點 click 為甚麼會連帶影響到其他 class 區塊 ? 因為這就是事件傳遞機制的捕獲跟冒泡事件 Huli 文章下圖來源為 Huli 的文章以下這段話擷取自 Huli 文章 DOM 的事件在傳播時，會先從根節點開始往下傳遞到 target，這邊你如果加上事件的話，就會處於 CAPTURING_PHASE，捕獲階段。target 就是你所點擊的那個目標，這時候在 target 身上所加的 eventListenr 會是 AT_TARGET 這一個 Phase。你在點擊那一個 td 的時候，這一個點擊的事件會先從 window 開始往下傳，一直傳到 td 為止，到這邊就叫做 CAPTURING_PHASE，捕獲階段。接著事件傳遞到 td 本身，這時候叫做 AT_TARGET。最後事件會從 td 一路傳回去 window，這時候叫做 BUBBLING_PHASE，冒泡階段。所以，在看一些講事件機制的文章的時候，都會看到一個口訣：先捕獲，再冒泡 在監聽時函式後面加上 true 就是捕獲，false 是冒泡 12345678910111213141516addEvent('.one');addEvent('.two');addEvent('button');function addEvent(className){ document.querySelector(className) .addEventListener('click', function(){ console.log(className, '捕獲') },true) document.querySelector(className) .addEventListener('click', function(){ console.log(className, '冒泡') },false)} codepen 當我點擊 click 就算我把順序顛倒過來，它還是會先捕獲在冒泡，跟上圖一樣 資料來源: [FE102] 前端必備：JavaScript","link":"/2020/08/16/220200816-javasript/"},{"title":"AJAX","text":"透過 XMLHttpRequest 物件跨瀏覽器撈資料MDN 連結XMLHttpRequest 是瀏覽器跟伺服器要資料時必須存在的物件 12var xhr = new XMLHttpRequest();xhr.open(' 格式 ',' 讀取的網址 ', A ) 格式: get(讀去資料) / post(傳送資料到伺服器)A 是 true/false (同步或是非同步)true 是程式不等回傳結果，繼續往下執行false 是會等回傳結果再決定要不要繼續執行 在 log 輸入 xhr 就會顯示相對應的資料，打開後顯示的各種格式(目前還沒輸入格式跟網址)其中 readyState = 0 是代表已經產生一個 XMLHttpRequest 但還沒連結到我要撈的資料圖片來源 MDN: json 連結 12var xhr = new XMLHttpRequest();xhr.open('get', 'https://hexschool.github.io/ajaxHomework/data.json', true) 輸入完整格式跟網址後 readyState 顯示 1 ，意思是目前選擇了格式，但還沒把資料送出去 目前只要 get 資料並非真的要傳送出去所以用 null 123var xhr = new XMLHttpRequest();xhr.open('get', 'https://hexschool.github.io/ajaxHomework/data.json', true)xhr.send(null); 會發現有撈到資料，readyState 顯示 4 ，意思是完成下載操作 AJAX 非同步觀念1234var xhr = new XMLHttpRequest();xhr.open('get', 'https://hexschool.github.io/ajaxHomework/data.json', true)xhr.send(null);console.log(xhr.responseText); 照理說我們用 console.log 看資料時應該要顯示，但為甚麼會顯示空直?原因是用了 true 非同步，他不會等資料有沒有回傳，而是直接往下執行，所以console.log(xhr.responseText)是撈不到資料的，相反的如果使用 false 則是會等資料回傳，收到資料後再繼續往下執行，如下圖 1234var xhr = new XMLHttpRequest();xhr.open('get', 'https://hexschool.github.io/ajaxHomework/data.json', false)xhr.send(null);console.log(xhr.responseText); 但是當我們在往後執行程式時，不可能讓資料回傳再執行，必須讓程式繼續執行並且抓到資料，所以我們使用 onload 監聽事件，並改成 true 非同步 123456var xhr = new XMLHttpRequest();xhr.open('get', 'https://hexschool.github.io/ajaxHomework/data.json', true)xhr.send(null);xhr.onload = function(){ console.log(xhr.responseText)} 載入完時，觸發 onload 事件然後擷取 xhr.responseText 的資料. 接下來要在網頁上顯示 王小名 1&lt;div class=&quot;name&quot;&gt;&lt;/div&gt; 12345678var xhr = new XMLHttpRequest();xhr.open('get', 'https://hexschool.github.io/ajaxHomework/data.json', true)xhr.send(null);xhr.onload = function () { console.log(xhr.responseText) var str = JSON.parse(xhr.responseText); document.querySelector('.name').textContent = str[0].name} 把 xhr.responseText 轉成物件，再從這物件中提取第一筆資料(JS 中第一筆為0) 總結 AJAX 動作: 建立 XMLHttpRequest 將資料傳送到對方伺服器裡 回傳資料到自己的瀏覽器 對資料進行擷取 資料來源:JavaScript 入門篇 - 學徒的試煉","link":"/2020/08/16/20200816-AJAX/"},{"title":"偵聽圖片的 load 事件","text":"現在要製作一個當圖片讀取的時候，顯示 loading 讀取完顯示 complate 的小範例先用簡單的 v-if 、 else 判斷式，在將判斷式的值綁到圖片上隨機圖片網址 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;h1 v-if='loading'&gt;Loading&lt;/h1&gt; &lt;h2 v-else&gt;complate&lt;/h2&gt; &lt;img @load='loading=false' src=&quot;https://picsum.photos/300/300&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ loading: true, }})&lt;/script&gt; codepen 接下來加一點 CSS 樣式，讓畫面稍微生動一些在 img 動態綁定到 imgClass 上，並加入 computed 屬性 123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;h1 v-if='loading'&gt;Loading&lt;/h1&gt; &lt;h2 v-else&gt;complate&lt;/h2&gt; &lt;img :Class='imgClass' @load='loading=false' src=&quot;https://picsum.photos/300/300&quot; alt=&quot;img&quot;&gt;&lt;/div&gt;&lt;style&gt;.img.hide{ opacity: 0;}.img{ transition: opacity 1s;}&lt;/style&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ loading: true, }, computed:{ imgClass(){ if(this.loading){ return 'img hide'; }else{ return 'img'; } } }})&lt;/script&gt; codepen 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/20/20200819-%E5%9C%96%E7%89%87%E8%AE%80%E5%8F%96/"},{"title":"偵聽按鍵事件","text":"透過按下 enter 鍵之外，還要知道按下的是”什麼按鍵”，因為鍵盤上每個按鍵都有自己的 keyCode ，我們必須使用 console.log(evt.keyCode) 找出按鍵相對應的數字，例如: enter 為 63 、Q 為 229、alt 為 18 …等等。codepen 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;input&quot; @keydown=&quot;keydown&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ input:'', list:[] }, methods:{ keydown(evt){ // console.log(evt.keyCode); if(evt.keyCode === 13){ this.list.push(this.input); this.input=''; } }, },})&lt;/script&gt; keydown 是一個偵聽事件，在按下 enter 時會執行 keydown 函式，同時也會傳入一個參數 evt (evt 是 event 事件的縮寫)，這參數是鍵盤按鍵的參數所以是 evt.keyCode keydown 除了用 keyCode 傳入以外，還有一個更簡潔的簡單的方法 : 修飾句。就是連 if 判斷式都不需要，直接在 keydown 後面加上 .enter，也會有一樣的效果 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;input&quot; @keydown.enter=&quot;keydown&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ input:'', list:[] }, methods:{ keydown(){ this.list.push(this.input); this.input=''; } },})&lt;/script&gt; codepen 除了在 keydown 後面加上 .enter 之外還可意換別的按鍵，例如: 我改成 f5 ，f5 是重新整理頁面，那如果不想他觸發”原本”會發生的事(指重整頁面)，那要在前面加上 prevent 來取消”原本”會發生的事情。(經過測試 prevent 加在任一鍵的前後都可以) 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;input&quot; @keydown.prevent.f5=&quot;keydown&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ input:'', list:[] }, methods:{ keydown(){ this.list.push(this.input); this.input=''; } },})&lt;/script&gt; codepen 如果有觀念錯誤需要更正，還請指正，謝謝。 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/20/%E5%81%B5%E8%81%BD%E6%A1%88%E4%BB%B6/"},{"title":"語法修飾","text":"防止預設事件發生: preventDefaulta 連結預設是開新分頁，但我想要點 a 連結就跳出 alert 同時又不要開新的分頁，這時候就要用 preventDefault 。先偵聽一個事件 linkClick ，並給 linkClick 一個函式，點擊 a 連結時為了要取消預設行為(開新分頁)，所以在函式內新增 e.preventDefault()。 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt;&lt;a href=&quot;https://www.google.com/&quot; target=&quot;_blank&quot; @click=&quot;linkClick&quot; &gt; google &lt;/a&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ }, methods:{ linkClick(e){ e.preventDefault(); alert(&quot;不開新頁面&quot;) } }})&lt;/script&gt; codepen 這個方法會常常用在 form submit 上，因為原本預設行為是透過網頁讀取並取得網址資源，但我們會希望網頁不要重新讀取同時又可以取得網頁資源，這時就可以在 form 裡面呼叫 e.preventDefault() 。 方法二：精簡寫法，直接在 click 後面加上 prevent 就結束了。 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt;&lt;a href=&quot;https://www.google.com/&quot; target=&quot;_blank&quot; @click.prevent=&quot;linkClick&quot; &gt; google &lt;/a&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ }, methods:{ linkClick(){ alert(&quot;不開新頁面&quot;) } }})&lt;/script&gt; codepen 防止子元件連動: stop、 self12345678910111213141516171819202122232425262728&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;box&quot; @click=&quot;msg = 'c'&quot;&gt; &lt;div class=&quot;box&quot; @click=&quot;msg = 'b'&quot;&gt; &lt;div class=&quot;box&quot; @click=&quot;msg = 'a'&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;h1&gt;{{msg}}&lt;/h1&gt;&lt;/div&gt;&lt;style&gt;.box{ display: inline-block; min-width: 100px; min-height: 100px; padding: 30px; border: 3px solid red;}&lt;/style&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ msg:'' },})&lt;/script&gt; codepen 當我點擊最裡面正方形的時候會出現 c 而不是 a，原因是最裡面的 box 是最外面 box 的 children ，所以一旦點擊最裡面的 box 就會一層一層往上找到最外層的 box 。這時候就可以在 click 後面加上 stop 或是 self 來防止事件往上層找。 1. stop 是調用event.stopPropagation() ，防止事件往上一層傳。2. self 只當事件是從偵聽器綁定的元素本身觸發時才觸發回調，就是只有自己本身發出的不然不會觸發事件。假設 div 包了 100 層，事件是點擊第 2 層才會觸發，那就算我點擊外面第 1 層或是裡面的 3~100 層都是不會觸發的。 範例如下： 12345678910111213141516171819202122232425262728&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;box&quot; @click.self=&quot;msg = 'c'&quot;&gt; &lt;div class=&quot;box&quot; @click.self=&quot;msg = 'b'&quot;&gt; &lt;div class=&quot;box&quot; @click.stop=&quot;msg = 'a'&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;h1&gt;{{msg}}&lt;/h1&gt;&lt;/div&gt;&lt;style&gt;.box{ display: inline-block; min-width: 100px; min-height: 100px; padding: 30px; border: 3px solid red;}&lt;/style&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ msg:'' },})&lt;/script&gt; codepen 參考資料: 官方文件參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/20/%E8%AA%9E%E6%B3%95%E4%BF%AE%E9%A3%BE/"},{"title":"Vue組件的使用","text":"Vue 組件是預先定義好的模組，包含 html 的視覺元素、綁定的資料跟偵聽器..等等，類似 Vue 實例，組件的好處是可以重複使用，在開發上可以只專注在一小區塊，維護也很方便 Vue.component 前面會先傳入參數的名稱，後面的參數是 option ，option 是用模板 template 定義視覺元素，也直接在模板裡面去定義內容，舉例 : 在模板裡面定義 html 的內容 (hello world) ，然後在 html 裡面定義 #app 並在裡面放入 my-component 標籤，而 my-component 並非是 html 標籤，是我在 Vue.component 定義好的。 Vue.component 有個特別的規範，就是前面的參數要全小寫並加上「 - 」分開，請養成習慣!，同時 Vue.component 的宣告必須在 new Vue 之前 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;!-- 此為 Global 的 component --&gt;&lt;script&gt;Vue.component('my-component',{ template:'&lt;div&gt;hello world&lt;/div&gt;',})new Vue({ el:&quot;#app&quot;,})&lt;/script&gt; 此範例是全域都可以使用的codepen 除了全域( Global )宣告以外還有 local 的宣告，它只會存在 Vue 實例裡面 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, components:{ 'my-component':{ template: '&lt;div&gt;hello wrold&lt;/div&gt;' }, }})&lt;/script&gt; 在 new Vue 裡面給一個屬性 components，屬性的 key 是字串 key my-component 也是組件名稱codepen 但是 local 有缺點，就是如果我宣告兩個 div ，但只會顯示一個 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, components:{ 'my-component':{ template: '&lt;div&gt;hello wrold&lt;/div&gt;' }, }})new Vue({ el:'#app2',})&lt;/script&gt; 它只會顯示一個 div 那用 Global 宣告就不會有這問題 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('my-component',{ template: '&lt;div&gt;hello wrold&lt;/div&gt;'})new Vue({ el:&quot;#app&quot;,})new Vue({ el:'#app2',})&lt;/script&gt; 這樣就會有兩個實例codepen 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/20/Vue%20%E7%B5%84%E4%BB%B6%E7%9A%84%E8%A8%BB%E5%86%8A%E8%88%87%E4%BD%BF%E7%94%A8/"},{"title":"表單綁定","text":"文字輸入v-model 可以做雙向綁定，但它同時也等於 v-bind 的 value 跟偵聽 input 的事件。 12345678910111213141516171819&lt;div id=&quot;app&quot;&gt;&lt;!-- &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; --&gt; &lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;setMessage&quot;&gt; &lt;h1&gt;{{message}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:'#app', data:{ message: '', }, methods:{ setMessage(e){ this.message = e.target.value; } }})&lt;/script&gt; codepensetMessage 函式會接收一個參數(evt 事件)，並用事件發出的 target 找到input 元素，那 e.target.vlaue 就是使用者輸入的值。 多行輸入: textarea用 v-model 一樣可以雙向綁定，但是他不會換行，範例如下 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt; &lt;h1&gt;{{message}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:'#app', data:{ message: '', },})&lt;/script&gt; codepen 這時候就要用 pre 標籤，它可以保存 message 裡面的換行字元，範例如下 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;&lt;!-- &lt;h1&gt;{{message}}&lt;/h1&gt; --&gt; &lt;pre&gt;{{message}}&lt;/pre&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:'#app', data:{ message: '', },})&lt;/script&gt; codepen 或是不想用 pre 標籤鄉用 h1 的話可以在 css 裡面加上 white-space: pre; 也會有同樣的效果。 也可以套用一開始單行 v-model 一開始單行 v-model 轉換成 v-bind 跟 v-on 一樣可以運行 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;textarea @input=&quot;setMessage&quot;&gt;{{message}}&lt;/textarea&gt; &lt;pre&gt;{{message}}&lt;/pre&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:'#app', data:{ message: '', }, methods:{ setMessage(e){ this.message = e.target.value; } }})&lt;/script&gt; codepen 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/21/%E8%A1%A8%E5%96%AE%E7%B6%81%E5%AE%9A/"},{"title":"表單綁定—按鈕","text":"checkbox單選互動按鈕:將 true &amp; false 綁定到一個值上面，並做出沒勾選的話就會跳出 alert 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;chk&quot; v-model=&quot;agree&quot;&gt; &lt;label for=&quot;chk&quot;&gt;agree&lt;/label&gt; &lt;h1&gt;{{agree}}&lt;/h1&gt; &lt;button @click=&quot;submit&quot;&gt;submit&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ agree: false, }, methods:{ submit(){ if( this.agree !== true){ alert('agreeeeeeee'); return } // 表單送出後要做的事情... } }})&lt;/script&gt; codepen 多選互動按鈕:這可以應用在客戶在什麼時段方便取貨或是什麼時方便聯絡等地方。 給定三個時段，也給三個時段的 value ，同時在點選時段的時候我希望能以陣列的方式呈現 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;可以聯絡的時段:&lt;/h1&gt; &lt;input type=&quot;checkbox&quot; id=&quot;chk1&quot; value=&quot;8:00~12:00&quot; v-model=&quot;times&quot;&gt; &lt;label for=&quot;chk1&quot;&gt;morning&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;chk2&quot; value=&quot;13:00~ 18:00&quot; v-model=&quot;times&quot;&gt; &lt;label for=&quot;chk2&quot;&gt;afternoon&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;chk3&quot; value=&quot;19:00~21:00&quot; v-model=&quot;times&quot;&gt; &lt;label for=&quot;chk3&quot;&gt;evening&lt;/label&gt; &lt;h2&gt;{{times}}&lt;/h2&gt; &lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ times: [], },})&lt;/script&gt; codepen透過勾選的順序決定誰要先呈現第一個，例如我先勾選 evening 再勾 afternoon就會呈現下圖順序 radio這是應用在表單填寫性別或是單個選項等地方。給 2 個選項，在點擊 label 時會呈現 value ，要額外呈現 value 就要用 ， v-model 做雙向綁定，那 v-model 要空值或是預設值都可以。 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;chk1&quot; value=&quot;male&quot; v-model=&quot;gender&quot;&gt; &lt;label for=&quot;chk1&quot;&gt;male&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;chk2&quot; value=&quot;female&quot; v-model=&quot;gender&quot;&gt; &lt;label for=&quot;chk2&quot;&gt;female&lt;/label&gt; &lt;h1&gt;{{gender}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ gender: 'male', },})&lt;/script&gt; codepen 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/21/%E8%A1%A8%E5%96%AE%E7%B6%81%E5%AE%9A%E2%80%94%E6%8C%89%E9%88%95/"},{"title":"下拉選單","text":"先將 select 用 v-model 做作雙向綁定，因為 number 是空字串，所以在一開始 option 會指定到 value 為空值的選項。假設 option 裡面沒有 value ，那 option 就會顯示 2020 等年分，但給了 value 就會顯示 value 值。 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;number&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;select number&lt;/option&gt; &lt;option value=&quot;001&quot;&gt;2020&lt;/option&gt; &lt;option value=&quot;002&quot;&gt;2021&lt;/option&gt; &lt;option value=&quot;003&quot;&gt;2022&lt;/option&gt; &lt;!--&lt;option&gt;2020&lt;/option&gt; &lt;option&gt;2021&lt;/option&gt; &lt;option&gt;2022&lt;/option&gt; --&gt; &lt;/select&gt; &lt;h1&gt;{{number}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ number: '', }})&lt;/script&gt; codepen 下拉選單還可以綁定到陣列上 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;select&gt; &lt;option v-for=&quot;number in numbers&quot; :value=&quot;number&quot;&gt;{{number}}&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ numbers: [2020, 2021, 2022], }})&lt;/script&gt; 利用 v-for 的方式將 option 內的 value 指定為 number，在用 v-model 將初始值設定為 2020，範例如下 12345678910111213141516&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;selectNumber&quot;&gt; &lt;option v-for=&quot;number in numbers&quot; &gt;{{number}}&lt;/option&gt; &lt;/select&gt; &lt;h1&gt;{{selectNumber}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ numbers: [2020, 2021, 2022], selectNumber: 2020, }})&lt;/script&gt; codepen 還有月份選擇，但有更為簡潔的寫法，範例如下 直接在 option 裡面寫最大數字，並將初始值 selectMonth 設定為 1，這樣就有下拉選單裡面有包含 12 個數字 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;selectMonth&quot;&gt; &lt;option v-for=&quot;month in 12&quot; &gt;{{month}}&lt;/option&gt; &lt;/select&gt; &lt;h1&gt;{{selectMonth}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ selectMonth: 1, }})&lt;/script&gt; codepen 陣列包物件寫法透過陣列將陣列內的物件顯示出來 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;select v-model=&quot;selectGender&quot;&gt; &lt;option v-for=&quot;option in options&quot; :value='option.value'&gt;{{option.text}}&lt;/option&gt; &lt;/select&gt; &lt;h1&gt;{{selectGender}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ options: [ { value:1, text:'boy'}, { value:2, text:'girl'}, { value:3, text:'others'} ], selectGender: 1, }})&lt;/script&gt; codepen 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/21/%E4%B8%8B%E6%8B%89%E9%81%B8%E5%96%AE/"},{"title":"圖片上傳","text":"在網站上填寫個資時，有些都會需要上傳證件照，這時候就可以用 v-on 。 在檔案上傳的 input 是沒辦法用 v-model ，所以必須改用 v-on 的 change 事件 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;file&quot; @change=&quot;selectFile&quot;&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, methods:{ selectFile(e){ const file = e.target.files.item(0); console.log(file); }, },})&lt;/script&gt; codepen e 就是 @change 的事件， e.target 就是發出事件的 input，後面的 files 是 filelist 的資料型態，用 console.log 可以看到以下屬性 但目前圖片還是沒辦法顯示，只能透過建立一個 FileReader ，並偵聽 FileReader 的 load 事件，程式碼如下 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;file&quot; @change=&quot;selectFile&quot;&gt; &lt;img :src=&quot;image&quot; width=&quot;200&quot;&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:&quot;#app&quot;, data:{ image: '', }, methods:{ selectFile(e){ const file = e.target.files.item(0); // console.log(file); const reader = new FileReader(); reader.addEventListener('load', this.imageLoaded); reader.readAsDataURL(file); }, imageLoaded(e){ this.image = e.target.result; }, },})&lt;/script&gt; codepen 在 input 裡的 type 是 file 的時候，e.target 就會有 files 屬性，如果在 input 標籤加上 multiple ，檔案會變成可以複選，但目前只要一個檔案，所以加上 item(0) ，然後建立一個新的 FileReader 並偵聽 load 事件，一旦 load 完，就會呼叫 imageLoaded 函式，在 reader 偵聽之後會 readAsDataURL ，DataURL 是指下圖很長的字串，也稱為 base64 編碼 ( base64 編碼就是可以把很長的英文跟數字轉成字串)，那這編碼可以指定成 image 當成 source。當 reader 發出 load 事件的時候就可以偵聽 imageLoaded 事件，並呼叫第 15行 imageLoaded 函式，函式會將 load 事件當成參數(e)，e.target 就是指第 11 行發出 load 事件的 reader 物件，reader 完之後會 result DataURL 屬性，在將 DataURL 指定到第 4 行的 image 。 那有時候圖會是壞掉的，如下圖 這時候可以在 img 標籤加上 v-if =”image” 來判斷要不要顯示圖片 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/22/%E5%9C%96%E7%89%87%E4%B8%8A%E8%88%B9/"},{"title":"data必須是函數","text":"data 必須是函數範例為簡單的計數器在第8行用 data 來 return 一個物件，這時的 data 必須是函式。如果 data 是物件的話，那 counter 是不會被宣告兩次的，但如果 data 是函式的時候，每次只要執行 +1 都會 return 出一個新物件，這樣組件在使用的時候，就不會同時被影響，因為 return 出來的物件都會是新建立的物件 1234567891011121314151617181920212223&lt;div id='app'&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script&gt;Vue.component('counter',{ data(){ return{ count: 0, } }, template:` &lt;div&gt; &lt;h1&gt;{{count}}&lt;/h1&gt; &lt;button @click='count+=1'&gt;+1&lt;/button&gt; &lt;/div&gt;`})new Vue({ el:'#app',})&lt;/script&gt; codepen 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/08/25/data%E5%BF%85%E9%A0%88%E6%98%AF%E5%87%BD%E6%95%B8/"},{"title":"Vue-Router","text":"新增路由路徑及連結 Vue-router:官方文件 透過切換網址來決定要顯示的組件內容，而切換網址就要用 router 來幫你達成! 在終端機切換到自己命名的資料夾並安裝 npm install vue-router --save 到 index.js 引入 Vue.use() ，啟用路由功能 1234567891011121314151617181920212223242526272829303132import Vue from 'vue'import VueRouter from 'vue-router'//以上為官方元件// 這邊路徑就是左邊檔案路徑，保險起見一律都不加 .vue 字尾!!!// 路徑除了 from 要加入根目錄的 '@' 以外，其他地方不要加import home from '@/components/HelloWorld'import page from '@/components/pages/page'Vue.use(VueRouter); //路由啟用。這行很重要!!export default new VueRouter({ // 這邊路徑是自訂的 routes: [ { name: &quot;元件呈現的名稱&quot;, path: &quot;對應的虛擬路徑&quot;, component: 對應的元件, }, { path: '/index', name: 'home', component: home }, { path: '/page', name: 'page', component: page }, ]}); export 解釋路由載入完啟用後，再到 main.js 載入路由配置 1234567891011121314import Vue from 'vue'import App from './App'import router from &quot;./router&quot;; //新增這行Vue.config.productionTip = falsenew Vue({ el: '#app', components: { App }, template: '&lt;App/&gt;', router, //跟這行}) 這邊示範一下透過設定的路徑來顯示組件內容 因為首頁(HelloWorld.vue)的路徑(path)我定義為 /index ，所以在網址上如果沒有輸入定義路徑會顯示下圖可以看到，畫面只會顯示 app.vue 的圖片沒有其他內容，但如果在網址後面輸入 /index ，就會顯示下圖這樣就可以看到 HelloWorld.vue 的內容 接下來使用 BS4 套件，來快速顯示組件的內容首先，在 index.html 引入 BS4 cdn有分頁才會有不同路徑，所以在 components 底下新增 pages 資料夾，裡面新增 page.vue 到 page.vue 新增模板記得在模板內加上 div (這邊用 hello 標籤示範)。接著在標籤內貼上 BS4 套件(這邊用 card 套件示範)，src 裡面的 …記得刪除!!，不然會錯誤!! 123456789101112&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;div class=&quot;card&quot; style=&quot;width: 18rem;&quot;&gt; &lt;img src=&quot;&quot; class=&quot;card-img-top&quot; alt=&quot;...&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Card title&lt;/h5&gt; &lt;p class=&quot;card-text&quot;&gt;Some quick example text to build on the card title and make up the bulk of the card's content.&lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Go somewhere&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 再來要製做可以切換組件內容的 navbar先把 app.vue 內容刪除，留下 app 標籤跟 router-view，img 也可以留下做分隔，並在裡面套入 BS4 導覽列套件，然後把不要的內容刪掉並補上 vue 的連結標籤，這邊的連結已經不是&lt; a href=”#” &gt; 了，而是 router-link ，連結路徑用 to ，這個路徑是 index.js 裡面自定義的路徑，記得要寫 router-view 這樣才可以顯示組件，如下圖 這邊說明一下 router-view：router-view 是呈現 router/index.js 裡面的元件，而 router/index.js 是設定各元件之間的連結 完成後會看到畫面如下沒有任何組件，因為網址還沒輸入任何自定義路徑 按一下 index，會顯示下圖 按一下 page，會顯示下圖 製作巢狀路由頁面接下來要做巢狀路由 注意!!!!在巢狀裡面一律不加斜號 ‘/‘ !!! 參考文件繼續在 pages 資料夾下新建立3個組件(這邊用 childX 示範)，然後再引入 BS4 套件的，只是要辨別而以所以用簡單的 alert 套件就好(其實是懶) 12345678這是 child1 範本&lt;template&gt; &lt;div&gt; &lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt; child1 &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 因為我們要在 page 裡面切換 child 組件，所以先把 card 套件內的內容通通刪掉並補上 router-view 1234567&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;div class=&quot;card&quot; style=&quot;width: 18rem;&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 接下來要自定義路徑，但這是巢狀路徑，所以要在 page 底下加上 children，這 children 是使用陣列，裡面內容就跟外面的物件一樣，但在的第一個子元件的路徑可以是空直，這樣只要切到 page 頁面就會自動載入 child1 元件，子元件下陣列內的路徑也甭加 ‘/‘ ，直接寫路徑名字就好。下面組件新增完後上面也要引入組件路徑。範例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import Vue from 'vue'import Router from 'vue-router'//以上為官方元件// 這邊路徑就是左邊檔案路徑import home from '@/components/HelloWorld'import page from '@/components/pages/page'import child1 from '@/components/pages/child1'import child2 from '@/components/pages/child2'import child3 from '@/components/pages/child3'Vue.use(Router) // 路由啟用。這行很重要!!export default new Router({ // 這邊路徑是自訂的 routes: [ { path: '/index', //對應的虛擬路徑 name: 'home', //元件呈現的名稱 component: home //對應的元件 }, { path: '/page', //對應的虛擬路徑 name: 'page',//元件呈現的名稱 component: page,//對應的元件 children: [ { path: '', //對應的虛擬路徑 name: 'child1',//元件呈現的名稱 component: child1,//對應的元件 }, { path: 'child2',//對應的虛擬路徑 name: 'child2',//元件呈現的名稱 component: child2,//對應的元件 }, { path: 'child3',//對應的虛擬路徑 name: 'child3',//元件呈現的名稱 component: child3,//對應的元件 }, ] }, ]}) OK，到目前為止我們只要切換網址就可以看到 child 組件了，先試試 page 頁我有在 app.vue 用 container 限制寬並置中 可以看到目前在 page 頁，並自動帶入 child1輸入 child2 如下圖 接下來要在 page 頁面下新增子分頁的連結， 1234567891011121314&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;router-link to=&quot;/page/&quot;&gt;child1&lt;/router-link&gt; &lt;router-link to=&quot;/page/child2&quot;&gt;child2&lt;/router-link&gt; &lt;router-link to=&quot;/page/child3&quot;&gt;child3&lt;/router-link&gt; &lt;!-- 也可以用 v-bind 動態綁定 name 的方式來連結路徑，下面示範 --&gt; &lt;router-link :to=&quot;{ name: 'child3' }&quot;&gt;child3&lt;/router-link&gt; &lt;div class=&quot;card&quot; style=&quot;width: 18rem;&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 結果如下圖，本想把 card 套件移除，但發現他剛好可以把 alert 套件框住不會滿版，就索性留著然後注意網址!!!在點擊子組件的時候就會切換到自訂義的網址，同時也顯示不同子頁面 參考資料：Vue 出電商網站Vue 官方文件搞搞就懂部落格","link":"/2020/08/30/router/"},{"title":"計算屬性(computed)","text":"計算用法: 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;number&quot; v-model='a'&gt; + &lt;input type=&quot;number&quot; v-model='b'&gt; = &lt;input type=&quot;text&quot; v-model='ans'&gt; &lt;br&gt;&lt;/div&gt;&lt;script&gt;new Vue({ el:'#app', data:{ a: 0, b: 0, c: 0 }, computed:{ ans(){ return parseInt(this.a)+parseInt(this.b); } }})&lt;/script&gt; codepencomputed 裡面的屬性不能跟 data、methods 撞名，同樣的在 ans 不能是箭頭函式，因為用箭頭函式，那 ans 裡面的 this 就會是 window 物件 除了簡單的計算外還有進階的用法，就是 computed 裡面除了宣告成函式外還可以宣告成物件 123456789101112131415161718new Vue({ el:'#app', data:{ a: 0, b: 0, c: 0 }, computed:{ ans:{ get(){ return parseInt(this.a)+parseInt(this.b); }, set(val){ this.b = parseInt(val) - parseInt(this.a) } } }}) codepenget 是指，當我需要 ans 值的時候，就會用 get 呼叫函式，取出 return 的值 set 是指，當我設定某個值到 ans 的時候，要用 set 的函式，那 set 函式它吃一個值( value )，範例是當我設定 ans 的時候就要算出 a or b 的值 參考資料:精通 VueJS 前端開發完全指南","link":"/2020/09/02/computed/"},{"title":"Vue出電商網站-1","text":"相關文件API文件進度commit 由於 Google Chrome 在後續 80 版本後會預設封鎖第三方 Cookie，所以在登入 Vue 課程 API 就會出現無法登入的問題，在這邊老師也補充相關解決方式連結 啟用一個 Vue Cli 並且 引用帶入專屬 API申請 API ，並載入先申請 API ，取得資料再安裝 Vue-Axios ，然後把 Vue-Axios 載入到 main.jsmain.js 載入順序是第三方套件盡量往上放，下面再放自己撰寫的組件 12345678// 第三方套件import Vue from 'vue'import axios from &quot;axios&quot;;import VueAxios from &quot;vue-axios&quot;;// 自己撰寫import App from './App'import router from './router' main.js 載入後到 app.vue 組件，透過 apiurl 網址來取得遠端資料，在 apiurl 下面有範本，可以直接取用 12345678910111213141516&lt;script&gt;export default { name: 'App', // 取得遠端資料 created() { const api = 'https://vue-course-api.hexschool.io/api/pkt/products' //api申請的路經 //所申請的API path this.$http.get(api).then((response) =&gt; { console.log(response.data) }) },}&lt;/script&gt; 然後用 console 確認API資料有沒有載入(記得刷新頁面)，查看產品裡面有個測試分類，確認是否跟自己的 API 一樣 修改 API 路徑，確認是否有抓到API 路徑在開發時段有可能會修改，為了方便管理，所以要去 config/dev.env.js 新增變數(dev.env.js 是開發中的環境，prod.env.js 是正式上線的環境) 123456789101112131415module.exports = merge(prodEnv, { NODE_ENV: '&quot;development&quot;', APIPATH:'&quot;https://vue-course-api.hexschool.io&quot;',// 這是伺服器路徑 COSTOMPATH:'&quot;pkt&quot;',// 這是自定義的路徑})------------下面這塊是重要提醒!!!!!!-------------------APIPATH路經尾巴不能有&quot;/&quot;，不然會出現&quot;你所查看的API不存在&quot;路徑是外面一個單引號，裡面再用雙引號包住錯誤示範:APIPATH:'&quot;https://vue-course-api.hexschool.io/&quot;',正確示範:APIPATH:'&quot;https://vue-course-api.hexschool.io&quot;', 新增好變數後就可以把路徑用字串模板跟變數的方式來呈現我們要確認 dev.env.js 的路徑是否有啟用，所以在 app.vue 輸入 console.log(process.env.APIPATH, process.env.COSTOMPATH); 輸入完若直接刷新頁面會出現下圖，顯示抓不到路徑這是正常的，解決方法是重新起動 vue npm run rdv !!! 再用 console 查看，就會正常顯示了 將路徑改成字串模板+變數確認變數有抓到後，接下來要把路經改用字串模板+變數來呈現(單引號記得改反引號) 123456789101112131415161718&lt;script&gt;export default { name: 'App', // 取得遠端資料 created() { // 字串模板記得改成 反引號!!! const api = `${process.env.APIPATH}/api/${process.env.COSTOMPATH}/products`; // console.log(process.env.APIPATH, process.env.COSTOMPATH); //api申請的路經 //所申請的API path this.$http.get(api).then((response) =&gt; { console.log(response.data) }) },}&lt;/script&gt; 然後重開 npm，確認是否抓到 引用 Bootstrap 套件，並客製化樣式接下來要將 Boostrap4 變數修改成自定義的變數，在此之前要先建立新的檔案並且把原本的變數檔存到要修改的資料夾內。Dashboard 模板首先用 npm 載入 Boostrap4npm install Boostrap --savenpm install --save-d sass-loader@7.1.0會限制版本是為了避免在&lt;style lang=&quot;scss&quot;&gt; 出錯，如下圖，此圖來源為 Simon 同學的範例為避免這狀況發生，所以這邊用舊版本示範 安裝好 npm 後重開，到 node_modules 資料夾下確認是否有載入 然後到 app.vue 把預設的 CSS 刪掉，並載入 Bootstrap4 1234&lt;style lang='scss'&gt;@import '~bootstrap/scss/bootstrap';//~bootstrap 是指載入 Boostrap 這個模組&lt;/style&gt; 這時候有可能是 sass-loader 沒裝，每個 cli 出來的 webpaack 版本可能會不一樣，如果沒跳錯就沒問題，如果有跳錯(如下圖)那就裝一下 npm i node-sass sass-loader --save ，再重開就好了 建立資料夾，新增檔案，拉連結接下來要客製化一些變數，這時候就需要將 Boostrap4 獨立出來，方便自定義跟管理 先在 assets 資料夾下新增 helper 資料夾，在到 node_modules / Bootstrap4 / SCSS / variables.scss，把 variables 另存新檔到 helper 資料夾內，這樣透過修改 variables 就可以將原本 Boostrap4 樣式進行客製化了 然後建立一個新的 all.scss 檔案，並載入方法跟要客製化的檔案 123@import '~bootstrap/scss/functions'; //載入 Boostrap4 套用變數的方法@import './helper/variables'; //有了上面的方法，才可以啟用自己定義的變數@import '~bootstrap/scss/bootstrap'; 再把 app.vue 的 style 改成下圖 1@import './assets/all'; //不要複製造抄，請確認 all.scss 放在哪 到目前為止，畫面仍會是正常的(如下圖) 接下來要加入 Bootstrap4 樣式來看看會有什麼變化，這邊用 button 套件示範把套件放在 app.vue 的 router-view 下方(如下圖) 這時候畫面就會顯示按鈕 現在要改樣式，先到 variables.scss 找要改的變數，這邊用 ‘indigo’ 示範 找到主題色做更改，這時候 primary 的顏色會被改掉 scopedscoped 是將樣式限制在某個組件內，以下示範先到 helloworld 組件看一下樣式會發現預設樣式是 scoped，代表這些樣式只會在 helloworld 組件內執行，不會影響到外層 app 組件 我們先看 router 配置圖可以看到 helloworld (內層)組件是被 app (外層)組件包住的，雖然是包住的但內外層是互不影響的，因為有 scoped 的關係，讓它們之間天人永隔! 我們先看看 helloworld (內層) style 裡的 a 連結，預設是 #42b983 淡綠色， 然後我們在 app (外層)組件內加入 a 連結 刷新畫面後，可以看到 a 連結的顏色會是紫色不是淡綠色，這是因為在 helloworld 有下 scoped ，所以樣式不會互相影響 如果文字看不懂，就看這張吧 如果不想讓各組件之間的樣式互相影響的話就必須在 style 加上 scoped ! 資料來源: Vue 出電商網站","link":"/2020/09/04/%E9%9B%BB%E5%95%86%E7%B6%B2%E7%AB%99-1/"},{"title":"串接上傳檔案 API","text":"串接上傳檔案 API上傳圖片 利用 formData MDN，模擬傳統表單傳送的形式 先看 串接 API現在要串接 API 並且雙向綁定圖片跟圖片的 url新增產品會有 url 跟 上傳圖片 新增上傳圖片的行為 將圖片拉進去，並查看上傳的圖片內容，可用 console.log(this) 查看 用開發者工具看 refs 底下有個 files 再往下看會找到 files 陣列 我們要取第一個值 欄位的 name 寫法如下: 12345678910111213141516171819202122232425262728293031uploadImg() { //利用 console 查看圖片內容 console.log(this) // 把 API 抓到的值，塞到 uploadFile const uploadFile = this.$refs.files.files[0] // 這是 web api ，看連結 const formData = new FormData() // 用 append 將欄位新增進去， // formData.append('放 api 的name', 要上傳的檔案) formData.append('file-to-upload', uploadFile) //接下來定義路徑，請看api，並注意 api 路徑 const url = `${process.env.APIPATH}/api/${process.env.MYPATH}/admin/upload` // 這邊上傳的行為有點不一樣 // this.$http(路徑, 傳送的內容, 物件，這物件要寫成 formdata 的格式) this.$http // 為什麼 post ? 請看 api 的 methods .post(url, formData, { headers: { // 把表單的形式改成 formdata，api 的 enctype 'Content-Type': 'multipart/form-data' } }) // 接下來看看回傳資料 .then((res) =&gt; { console.log(res.data) })} API 如果圖片上傳成功時，會回傳 我們實際將圖片拉進去後，看 log ，確認有成功上傳如果回傳格是錯誤，那就是檔名錯了，請改 png 檔 接下來要把圖片存下來，並對應到 tempProduct 的 imgUrl 1234567891011121314151617181920uploadImg() { console.log(this) const uploadFile = this.$refs.files.files[0] const formData = new FormData() formData.append('file-to-upload', uploadFile) const url = `${process.env.APIPATH}/api/${process.env.MYPATH}/admin/upload` this.$http .post(url, formData, { headers: { 'Content-Type': 'multipart/form-data' } }) .then((res) =&gt; { console.log(res.data) if (res.data.success) { this.tempProduct.imgUrl = res.data.imageUrl } }) } 由此圖可以看到圖片跟連結沒有綁定好 而我們用 Vue 開發工具看，確實是有拿到資料的 這時候可以用 vue 的 set 將資料強制帶入this.$set(在tempProduct裡面, '欄位=imgUrl', res.data.imageUrl)this.$set(this.tempProduct, 'imgUrl', res.data.imageUrl)然後上面再做圖片的雙向綁定 接下來再上傳一次圖片可以看到 input 跟圖片都顯示出來了 資料來源: Vue 出電商網站","link":"/2020/12/03/%E4%B8%B2%E6%8E%A5%E4%B8%8A%E5%82%B3%E6%AA%94%E6%A1%88%20API/"},{"title":"用 Vue 做出頁面的 Loading 效果","text":"vue-loading-overlay首先安裝 npm: npm install vue-loading-overlay再到 main.js 載入 1234567// Import componentimport Loading from 'vue-loading-overlay';// Import stylesheetimport 'vue-loading-overlay/dist/vue-loading.css';// 因為是全域每個 component 都會用，所以用 Vue.componentVue.component('Loading', Loading) 全域Loading接下來要在 components 裡面加入讀取的判斷式跟綁定先將 lading 預設好，只有在等待的時間下才會轉 isLoading: false, 然後把範例拿過來用 在div 內一層加上 &lt;loading :active.sync=&quot;isLoading&quot;&gt;&lt;/loading&gt; 接下來要在 AJAX 的行為上面新增 isLoading: false,在啟用 getProducts 的時候就會觸發 loading ( true )，在完成的時候結束( false )範例如下: 12345678getProducts() { const api = `${process.env.APIPATH}/api/${process.env.MYPATH}/products` this.isLoading = true this.$http.get(api).then((response) =&gt; { this.products = response.data.products this.isLoading = false })}, 然後再重新整理，畫面中間就會出現 Loading 的效果，再試試按下編輯或是新增然後直接按下確認也會有 Loading 的效果 這樣全域就完成了!! 局部 Loading再來要做局部的，我們要在新增或是編輯圖片那邊加上 loading 的效果 要加的地方在下圖紅框處 這邊偷懶一下直接用 CDN 載入 font-awesome 到 index.html 然後再到 Animating Icons 選一個自己喜歡的 loading 樣式這邊用 fa-spinner fa-spin 作範例因為要在上傳圖片的旁邊顯示 laoding 效果，所以我們把 fa-spinner fa-spin 加在 label 旁邊， 再到 data 函式加入決定局部 loading 的變數 再到模板那邊用 v-if 判斷做動態綁定 然後在上傳圖片的函示( uploadImg )內加入局部 loading 判斷 12345678910111213141516171819202122232425uploadImg() { // 在拉圖片進去讀取的時候 fileUpLoading 會是 true this.status.fileUpLoading = true const uploadFile = this.$refs.files.files[0] const formData = new FormData() formData.append('file-to-upload', uploadFile) //接下來定義路徑 const url = `${process.env.APIPATH}/api/${process.env.MYPATH}/admin/upload` this.$http .post(url, formData, { headers: { 'Content-Type': 'multipart/form-data' } }) .then((res) =&gt; { console.log(res.data) // AJAX 結束後 fileUpLoading 就 false this.status.fileUpLoading = false if (res.data.success) { // this.tempProduct.imgUrl = res.data.imageUrl console.log(this.tempProduct) this.$set(this.tempProduct, 'imgUrl', res.data.imageUrl) } })} 資料來源: Vue 出電商網站","link":"/2020/12/13/Loading/"},{"title":"安裝套件管理工具","text":"作業系統 在 mac 上是用 homebrew 在 Windwo 上是用 chocolatey chocolatey 算是一個可以用指令來下載的打包工具，安裝 chocolatey 方法也簡單，安裝工具的起手式是 choco install 後面打想要的工具名稱。 例如: 要下載 JAVA =&gt; choco install jdk8 要下載 cmder =&gt; choco install cmder 要下載 docker =&gt; choco install docker 要發大財 =&gt; choco install 發大財 以此類推~ 安裝安裝方法可以用 cmd 跟 PowerShell，這邊示範用 PowerShell 進入官網 官網 Chocolatey Install 那邊說明要用系統管理員的身分來執行，所以我們使用系統管理員身分開啟 PowerShell ，為了在安裝過程中可以不受限制又能提高安全性，所以我們使用Get-ExecutionPolicy 的指令來查看 初次安裝會先看到 Restricted (google 翻譯是受限制的)，我們要改成 AllSigned ，所以要下Set-ExecutionPolicy AllSigned 的指令，過程中會問執行這項變更會有風險要不要變更，回 Y 12345678910111213PS C:\\WINDOWS\\system32&gt; Get-ExecutionPolicyRemoteSignedPS C:\\WINDOWS\\system32&gt; Set-ExecutionPolicy AllSigned執行原則變更執行原則有助於防範您不信任的指令碼。如果變更執行原則，可能會使您接觸到 about_Execution_Policies 說明主題 (網址為https:/go.microsoft.com/fwlink/?LinkID=135170) 中所述的安全性風險。您要變更執行原則嗎?[Y] 是(Y) [A] 全部皆是(A) [N] 否(N) [L] 全部皆否(L) [S] 暫停(S) [?] 說明 (預設值為 &quot;N&quot;): y再下一次`Get-ExecutionPolicy`指令確認有沒有轉成 AllSignedPS C:\\WINDOWS\\system32&gt; Get-ExecutionPolicyAllSignedPS C:\\WINDOWS\\system32&gt; 然後再複製:Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 然後下 choco 指令確認一下有沒有安裝好，正常會顯示 Chocolatey v0.10.15 Chocolatey 後面帶版本號 安裝 cmder如果想在 window 環境下使用 linux 指令，那就要需要用到 cmder，如上所說要用 cmder 工具就系統管理員開啟 powershell，然後下 choco install cmder 指令，就開始安裝了 安裝方法如下: 安裝過程中會問2次是否要安裝腳本，選 Y 安裝，裝好後會顯示工具放置的路徑 依照顯示的路徑找到工具開啟就 ok 了!","link":"/2020/12/16/cmder/"},{"title":"簡易的 Git 操作","text":"簡介Git 是一個可控制程式碼版本的工具當我們在開發的時候為了不影響線上的產品，就會先開一個分支出來在分支上做開發，這樣既可以大膽的開發也不怕會影響到線上正在運行的版本，同時又做到程式碼的控管，是一個很方便的工具 Git 指令Git 有分幾個簡單寫常用的幾個指令git init: 在我們 local 端建立數據庫git add .: 加入索引git commit -m: 將目前加入索引的資料提交出去git push origin: 推送到遠端數據庫git pull: 從遠端數據庫拉取最新的版本git branch: 查看分支git checkout : 切換到該分支git log: 查看 git 歷史紀錄git status: 查看目前資料狀態git merge: 合併分支 工作上常用的大概是以上這幾種 安裝OS: window首先到 Git 官網下載 Git 或是用 chcoclatey 安裝也可以 ，輸入choco install git 初次安裝的話會需要設定使用者名稱跟密碼 初始化安裝完成後在桌面建立資料夾，並簡單新增檔案，然後再對資料夾案右鍵，選取 Git Bash Here會出現 Bash 視窗這樣就初始化完成了 加入索引接下來就可以開發了 本來是檔案內容是空的，現在加入一點基本資料，然後要將這資料加入索引當我們新增或是更改完成時就要將資料新增到索引，同時放到一個暫存區裡面因為 VScode 有內建 git add ，就是下圖紅框處，如果有更改某檔案的資料，在 changes 就會有紀錄，首先左邊選單選到 Source control 會看到有檔案變更，點擊紅框的 + 號，要加入索引就把滑鼠移至紅框，會出現 + 號，點擊就 add 了 add 新增索引後，如下圖 提交當確定好更改的檔案並加入索引後，我們要 commit ，把暫存區裡面的資料丟到儲存庫裡面通常 commit 後面都會接此次更改的資訊，寫法如下git commit -m &quot;add index.html&quot;，要記得空格跟加雙引號 然後推送至遠端數據庫 建立遠端儲存庫在推送至遠端數據庫之前，要先在遠端建立遠端數據庫，那這會用到 Github ，如果沒有 Github 要先辦一下登入後看到右上角有個 + 號，點擊候選取 New repository會出現以下畫面，然後再紅框處輸入遠端數據庫的名稱，這邊用 test1 示範，然後點擊下面的Create repository 接著會顯示以下畫面 推送至遠端數據庫當我們把資料都丟到數據庫後，接下來要將新增或是修改的檔案推送到遠端數據庫中git push origin test ，意思是將 test 這個分之 push 到遠端的數據庫中因為我剛剛已經 init、add、commit 了，所以現在就直接 push，點選右邊紅框的複製紐直接貼上 用 git log 指令確認一下狀態 在回到 Github 在刷新一次頁面，確認一下 這樣不管是 loacal 或是 remote，前置作業就算是完成了 製造分支接下來我們可以試著用分支開發造分支有兩種方法: git checkout -b 分支名稱: 這方法比較直接，輸入完直接造分支同時切到該分支上 git branch 分支名稱: 這方法會造分支但不會切換到該分支，必須再下 git checkout 分支名稱 才會切過去，以下示範我先用 branch 創造分支 dev2 ，然後再確認目前在哪個分支上(亮綠色有星號的就是在該分支上)但因為我創的是 dev2 ，所以還沒轉過去，要用 checkout 才可以切換過去 合併分支接下來流程跟上面步驟一樣 建立索引 add 或是 按 + 提交至儲存庫 git commit 推送至遠端 實際操作: 確認在哪個分之 在分支上新增 h2 內容，並加入索引 用 git status 確認目前更改的檔案有哪些 如下圖 提交到儲存庫後，左邊的暫存檔就會不見 再示範一次，新增 h3 內容我們可以點擊更改的檔案查看哪邊有高亮，有代表變更的地方 提交後。高亮就會不見 再推送到遠端git push origin 分支名稱 到遠端切換到分支上查看，確實有剛新增的內容 接下來要合併了切回 主支( main ) 可以看到沒有 h2、h3 的內容但再切回 dev1 分支查看是有的 合併時我們要先切到要被合併的那個分支上，可以用 git branch 確認高亮跟星號在哪，如下圖merge 完後 dev1 的內容就會被新增到主支(main)上，然後就可以繼續做開發了 參考資料把檔案交給 Git 控管","link":"/2020/12/20/git/"},{"title":"簡易表單驗證","text":"附上 GithubDemo 第一部分: 刻板+上色先寫好要一般 form 表單要填寫的資料， 使用者名稱 使用者信箱 密碼 密碼2次驗證 上色跟輸入框的間隔可依照個人喜好設定 1234567891011121314151617181920212223242526272829303132&lt;div class=&quot;container&quot;&gt;&lt;!-- 輸入使用者名稱 --&gt;&lt;form class='form' id='form'&gt; &lt;h1&gt;表單驗證&lt;/h1&gt; &lt;div class=&quot;formControl&quot;&gt; &lt;label for=&quot;username&quot;&gt;UserName:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;Key in UserName&quot;&gt; &lt;small class='failMessage'&gt;Error message&lt;/small&gt; &lt;/div&gt; &lt;!-- 輸入使用者e-mail --&gt; &lt;div class=&quot;formControl&quot;&gt; &lt;label for=&quot;email&quot;&gt;E-mail:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;Key in E-mail&quot;&gt; &lt;small class='failMessage'&gt;Error message&lt;/small&gt; &lt;/div&gt; &lt;!-- 輸入使用者密碼 --&gt; &lt;div class=&quot;formControl&quot;&gt; &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;Key in password&quot;&gt; &lt;small class='failMessage'&gt;密碼錯誤&lt;/small&gt; &lt;/div&gt; &lt;!-- 確認使用者密碼 --&gt; &lt;div class=&quot;formControl&quot;&gt; &lt;label for=&quot;confirmPassword&quot;&gt;Confirm Password:&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;confirmPassword&quot; placeholder=&quot;Key in password again&quot;&gt; &lt;small class='failMessage'&gt;請重新輸入密碼&lt;/small&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;/div&gt;&lt;script src=&quot;./all.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 第二部分: 驗證抓取 DOM先抓取 dom 元素，因為是抓 id 所以是用 # 1234567// 抓取 dom 元素const form = document.querySelector('#form')const username = document.querySelector('#username')const email = document.querySelector('#email')const password = document.querySelector('#password')const confirmPassword = document.querySelector('#confirmPassword') 常用的獨立寫出來因為只要寫錯就會顯示錯誤訊息，這動作很重複所以將這些函式獨立拉出來，利用 callback function 的方式重複使用要特別注意以下兩點 是第3行 formControl 必須要用 父元素 的方式不能用 class 選擇器，不然它只會抓取 class 選擇器的最後一個，不會抓到每個 input 輸入框的父層 第5行的 small 必須用 formControl 的方式抓，不能用 document ，不然會抓不到12345678910111213141516171819// 失敗顯示function showFail(input, message){ const formControl = input.parentElement formControl.className = 'formControl fail' const small = formControl.querySelector('small') small.innerText = message}// 成功顯示function showSuccess(input){ const formControl = input.parentElement formControl.className = 'formControl success'}// 第一字體變大寫function getFiledName(input){ return input.id.slice(0,1).toUpperCase() +input.id.slice(1).toLowerCase()} 取消重複性因為每個 dom 的 input 都要驗證的話就會有很多 if else 判斷式，這時候可以用 javascript 的 forEach 來讀取每個 dom ，然後再寫一次 if else 就可以每個都判斷 checkInput 裡面的值用陣列顯示，那每個質都要被讀取到就用 forEach ，在陣列中的 dom 因為綁了 input 所以直接帶入是否是空值得判斷式，因為如果寫在裡面會太大包，造成日後不好維護，外加太醜，所以這邊直接用 callback function 的方式 12345678910111213// 輸入框輸入確認function checkInput(inputId){ inputId.forEach(inputArr)}// 輸入框 callback functionfunction inputArr(input){ if(input.value.trim() === ''){ showFail(input, `${getFiledName(input)} is require`) }else{ showSuccess(input) }} 驗證使用者名稱長度的驗證為了防止使用者名字長度過長或是過短，所以要設定一個卡關機制 12345678910// 輸入使用者名稱跟密碼長度限制function checkLength(input, min, max) { if(input.value.length &lt; min){ showFail(input, `${getFiledName(input)} must be at least ${min} characters`) }else if (input.value.length &gt; max){ showFail(input, `${getFiledName(input)} must be less than ${max} characters`) }else{ showSuccess(input) }} 信箱驗證123456789101112// 信箱正規表達驗證function checkMail (input){ const re = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/ // return re.test(String(email).toLowerCase()) if(re.test(input.value)){ showSuccess(input) }else{ showFail(input, 'email is not valid') }} 密碼雙重驗證12345678// 密碼雙重驗證function checkPasswordMatch(password, confirmPassword){ if(password.value !== confirmPassword.value){ showFail(confirmPassword, 'password is not match') }} 執行123456789// 執行form.addEventListener('submit', function(e){ e.preventDefault() checkInput([username, email, password, confirmPassword]) checkLength(username, 3, 8) checkLength(password, 3, 12) checkMail(email) checkPasswordMatch(password, confirmPassword)}) Demo參考資料20 Web Projects With Vanilla JavaScript","link":"/2020/12/31/formVaild/"},{"title":"簡易版匯率轉換","text":"附上 GithubDemo 1. 用 JS 撰寫利用選擇器抓取 DOM 元素123456const currencyElOne = document.querySelector('#currencyOne')const currencyElTwo = document.querySelector('#currencyTwo')const amountElOne = document.querySelector('#amountOne')const amountElTwo = document.querySelector('#amountTwo')const swapEl = document.querySelector('#swap')const rateEl = document.querySelector('#rate') 監聽抓取 dom 的操作事件，同事綁定事件的操作12345// 監聽 DOM 狀態currencyElOne.addEventListener('change', caclulate)currencyElTwo.addEventListener('change', caclulate)amountElOne.addEventListener('input', caclulate)amountElTwo.addEventListener('input', caclulate) 事件操作API這邊要注意的是 Fetch API 的方式，在打完 API ，response 資料的時候，雖然資料已經是 JSON 格式，但 Fetch 必須再轉一次 JSON，變成 json promise，否則是抓不到後端回傳的資料的。參考文章 12345678910111213141516171819202122232425// 操作 DOM 同時執行運算function caclulate() { // 透過選取的 DOM 將該 DOM的值塞到新變數中 const currencyOne = currencyElOne.value const currencyTwo = currencyElTwo.value // 發送 request ，開始打 API fetch(`https://api.exchangerate-api.com/v4/latest/${currencyOne}`) // 後端傳送 response 回傳結果 .then(res =&gt; res.json())//將回傳結果轉換成 json 格式 .then(data =&gt; { // console.log(data) // 用陣列的方式抓去 keyValue，再將值塞到 rate 變數中 const rate = data.rates[currencyTwo] // console.log(rate) //將計算後的值放到綁定的 rate dom 中，同時計算當前匯率 rateEl.innerHTML = `1 ${currencyOne} = ${rate} ${currencyTwo}` // 幣值2的值 = 幣值1的值*匯率，將值四捨五入 amountElTwo.value = (amountElOne.value*rate).toFixed(2) })} 切換匯率，將匯率互相對調這邊要注意的是，必須要先將currencyElOne.value 塞到 temp 變數中，方便待會賦值，會這樣做是有原因的 以下列這段程式碼為例，分別用 console.log 查看值 12345678910111213swapEl.addEventListener('click',function () { const temp = currencyElOne.value currencyElOne.value = currencyElTwo.value console.log('currencyElOne.value', currencyElOne.value) currencyElTwo.value = currencyElOne.value console.log('currencyElTwo.value', currencyElTwo.value) // currencyElTwo.value = temp // console.log('temp', temp) caclulate()}) 結果如下圖 兩個轉換的匯率都會長一樣，而且匯率永遠都會卡 1，無法轉換，如下圖 為防止這樣的情況發生，可以就要先將 currencyElOne.value 塞到 temp 中，再查看 temp 值的，就可以抓到 currencyElOne.value 的值，如下圖 然後再將 temp 賦予到currencyElTwo.value，這樣就可以避免匯率卡1的問題，最後要記得執行計算。 完整函式如下 123456swapEl.addEventListener('click',function () { const temp = currencyElOne.value currencyElOne.value = currencyElTwo.value currencyElTwo.value = temp caclulate()}) 2. 用 jQuery 撰寫抓取 DOM ，同時綁定事件先將每個 DOM 事件切割成一小部分，撰寫方法也要為簡單，步驟如下: 抓取 DOM 元素 $('#currencyOne') 後面再接事件change， 事件裡面會包發生的動作 caclulate() 執行 caclulate()12345678910111213141516171819202122// 將 dom 切割成小事件// 監聽 currencyOne 選取值$('#currencyOne').change(function(){ caclulate()})// 監聽 amountOne 選取值$( '#amountOne').change(function(){ caclulate()})// 監聽 currencyTwo 選取值$( '#currencyTwo').change(function(){ caclulate()})// 監聽 amountTwo 選取值$( '#amountTwo').change(function(){ caclulate()})caclulate() 事件裡面會包發生的動作這邊示範用 jquery ajax 打 api 1234567891011121314151617181920212223242526// 變動容器內的 dom，同時計算匯率function caclulate(){ // 用 jquery 的方式命名變數 let currencyOne = $('#currencyOne').val() let currencyTwo = $('#currencyTwo').val() let rate = $('#rate').val() // 用 ajax 打 api $.ajax({ methods: 'GET', url: `https://api.exchangerate-api.com/v4/latest/${currencyOne}`, }) // 後端 respose 資料，將資料用 res 命名 .done(function(res){ // 可用 console.log(res) 查看 response api // 將後端的資料塞到 rate 裡面，[currencyTwo] 是抓取物件 keyValue let rate = res.rates[currencyTwo] // 用 console.log(rate) 查看是否有抓到 keyValue // 將匯率轉換後的值塞到 amountTwo dom 裡面，並4捨5入取到第2位 $('#amountTwo').val(($('#amountOne').val() * rate).toFixed(2)) // 將轉換的匯率顯示在各匯率之間 $('#rate').text(`1 ${currencyOne} = ${currencyTwo} * ${rate}`) })} 動作的匯率對調函式邏輯跟上面 js 的一樣，差別寫法上會有些微的不同 1234567// 按下 swap dom 會將匯率對調$('#swap').click(function(){ let temp = $('#currencyOne').val() $('#currencyOne').val($('#currencyTwo').val()) $('#currencyTwo').val(temp) caclulate()}) 參考資料:JavaScript Fetch API 使用教學20 Web Projects With Vanilla JavaScript","link":"/2021/01/08/changeRate/"}],"tags":[{"name":"d-flex","slug":"d-flex","link":"/tags/d-flex/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"v-if","slug":"v-if","link":"/tags/v-if/"},{"name":"v-for","slug":"v-for","link":"/tags/v-for/"},{"name":"v-on","slug":"v-on","link":"/tags/v-on/"},{"name":"v-model","slug":"v-model","link":"/tags/v-model/"},{"name":"執行環境","slug":"執行環境","link":"/tags/%E5%9F%B7%E8%A1%8C%E7%92%B0%E5%A2%83/"},{"name":"cli","slug":"cli","link":"/tags/cli/"},{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"v-else","slug":"v-else","link":"/tags/v-else/"},{"name":"v-bind","slug":"v-bind","link":"/tags/v-bind/"},{"name":"eventListener","slug":"eventListener","link":"/tags/eventListener/"},{"name":"callback function","slug":"callback-function","link":"/tags/callback-function/"},{"name":"event","slug":"event","link":"/tags/event/"},{"name":"onSubmit","slug":"onSubmit","link":"/tags/onSubmit/"},{"name":"preventDefault","slug":"preventDefault","link":"/tags/preventDefault/"},{"name":"stop","slug":"stop","link":"/tags/stop/"},{"name":"self","slug":"self","link":"/tags/self/"},{"name":"component","slug":"component","link":"/tags/component/"},{"name":"Vue 組件的 data","slug":"Vue-組件的-data","link":"/tags/Vue-%E7%B5%84%E4%BB%B6%E7%9A%84-data/"},{"name":"Router","slug":"Router","link":"/tags/Router/"},{"name":"computed","slug":"computed","link":"/tags/computed/"},{"name":"8-1用 v-for 把陣列轉換為一組元素","slug":"8-1用-v-for-把陣列轉換為一組元素","link":"/tags/8-1%E7%94%A8-v-for-%E6%8A%8A%E9%99%A3%E5%88%97%E8%BD%89%E6%8F%9B%E7%82%BA%E4%B8%80%E7%B5%84%E5%85%83%E7%B4%A0/"},{"name":"8-2用 v-for 把一個物件轉換為一組元素","slug":"8-2用-v-for-把一個物件轉換為一組元素","link":"/tags/8-2%E7%94%A8-v-for-%E6%8A%8A%E4%B8%80%E5%80%8B%E7%89%A9%E4%BB%B6%E8%BD%89%E6%8F%9B%E7%82%BA%E4%B8%80%E7%B5%84%E5%85%83%E7%B4%A0/"},{"name":"8-3修改陣列或物件的注意事項","slug":"8-3修改陣列或物件的注意事項","link":"/tags/8-3%E4%BF%AE%E6%94%B9%E9%99%A3%E5%88%97%E6%88%96%E7%89%A9%E4%BB%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"chocolatey","slug":"chocolatey","link":"/tags/chocolatey/"},{"name":"cmder","slug":"cmder","link":"/tags/cmder/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"formValid","slug":"formValid","link":"/tags/formValid/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"作品集","slug":"作品集","link":"/tags/%E4%BD%9C%E5%93%81%E9%9B%86/"}],"categories":[{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Flex","slug":"Flex","link":"/categories/Flex/"},{"name":"電商網站","slug":"電商網站","link":"/categories/%E9%9B%BB%E5%95%86%E7%B6%B2%E7%AB%99/"},{"name":"chocolatey","slug":"chocolatey","link":"/categories/chocolatey/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"作品集","slug":"作品集","link":"/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"}]}